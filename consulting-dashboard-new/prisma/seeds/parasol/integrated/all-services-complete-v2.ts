import { PrismaClient as ParasolPrismaClient } from '@prisma/parasol-client'
import { readFileSync } from 'fs'
import { join } from 'path'

const parasolDb = new ParasolPrismaClient({
  datasources: {
    db: {
      url: process.env.PARASOL_DATABASE_URL || 'file:./prisma/parasol-service/data/parasol.db'
    }
  }
})

interface ServiceConfig {
  name: string
  displayName: string
  description: string
  domainLanguageFile: string
  capabilities: Array<{
    name: string
    displayName: string
    description: string
    category: 'Core' | 'Support' | 'Management'
    definition: string
    operations: Array<{
      name: string
      displayName: string
      pattern: 'Workflow' | 'CRUD' | 'Analytics' | 'Communication' | 'Administration'
      goal: string
      roles: string[]
      businessStates: string[]
      design: string
    }>
  }>
}

const services: ServiceConfig[] = [
  {
    name: 'secure-access',
    displayName: 'セキュアアクセスサービス',
    description: '認証・認可・監査を通じて、システムへの安全なアクセスを保証',
    domainLanguageFile: 'secure-access-v2.md',
    capabilities: [
      {
        name: 'access-control',
        displayName: 'アクセスを安全に管理する能力',
        description: 'ユーザー認証、権限管理、監査ログを通じて安全性を確保',
        category: 'Core',
        definition: `# アクセスを安全に管理する能力

## 定義
組織のセキュリティポリシーに基づき、システムへのアクセスを制御し、不正アクセスを防止する組織的能力

## 責務
- ユーザーの身元確認と認証
- 権限に基づくアクセス制御
- セキュリティイベントの記録と監査
- コンプライアンス要件の遵守
- セキュリティインシデントの早期発見と対応

## 提供価値
- セキュリティリスクの最小化: 不正アクセス試行を99%以上検知・ブロック
- コンプライアンス要件の充足: 監査で100%適合を維持
- 監査証跡の提供: 全アクセスログの完全な記録と検索可能性
- 不正アクセスの防止: 多要素認証により侵害リスクを95%削減
- 組織信頼性の向上: セキュリティ認証取得による顧客信頼度向上

## 実現手段
- ユーザーを認証する
- 権限を管理する
- アクセスを監査する

## 成熟度レベル
- **現在**: レベル3（定義され管理されている）
- **目標**: レベル4（定量的に管理されている）
- **改善計画**: セキュリティメトリクスの自動監視導入とリアルタイム脅威検知システムの構築

## 依存関係
- **前提ケーパビリティ**: なし（基盤的能力）
- **関連ケーパビリティ**: コンプライアンス管理能力、リスク管理能力`,
        operations: [
          {
            name: 'authenticate-user',
            displayName: 'ユーザーを認証する',
            pattern: 'Workflow',
            goal: 'ユーザーの身元を確実に確認し、システムへの安全なアクセスを提供',
            roles: ['エンドユーザー', 'セキュリティシステム', 'セキュリティ管理者'],
            businessStates: ['未認証', '認証中', 'MFA待機', '認証完了', '認証失敗'],
            design: `# ビジネスオペレーション: ユーザーを認証する

## 概要
**目的**: ユーザーの身元を確実に確認し、システムへの安全なアクセスを提供する
**パターン**: Workflow
**ゴール**: 不正アクセスを防止しながら、正当なユーザーに迅速で確実な認証を提供

## 関係者とロール
- **エンドユーザー**: 自身の認証情報を正確に入力し、セキュリティ要件に協力
- **セキュリティシステム**: 認証情報の検証、リスク評価、アクセス制御の実行
- **セキュリティ管理者**: 認証ポリシーの設定、異常検知、インシデント対応

## プロセスフロー
\`\`\`mermaid
flowchart LR
    A[ログイン開始] --> B[認証情報入力]
    B --> C[一次認証検証]
    C --> D{認証成功?}
    D -->|失敗| E[エラー表示]
    D -->|成功| F[MFA要求]
    F --> G[MFA検証]
    G --> H{MFA成功?}
    H -->|失敗| E
    H -->|成功| I[セッション作成]
    I --> J[ダッシュボード表示]
    E --> K[ログイン再試行]
\`\`\`

### ステップ詳細
1. **認証情報入力**: ユーザーがメールアドレスとパスワードを入力
2. **一次認証検証**: システムがハッシュ化されたパスワードと照合
3. **MFA検証**: SMS、認証アプリ、またはハードウェアトークンによる追加認証
4. **セッション作成**: 認証成功時にJWTトークンとセッション情報を生成
5. **アクセス記録**: 認証試行をすべて監査ログに記録

## ビジネス状態
\`\`\`mermaid
stateDiagram-v2
    [*] --> 未認証
    未認証 --> 認証中: ログイン開始
    認証中 --> MFA待機: 一次認証成功
    認証中 --> 認証失敗: 一次認証失敗
    MFA待機 --> 認証完了: MFA成功
    MFA待機 --> 認証失敗: MFA失敗
    認証失敗 --> 未認証: 再試行
    認証完了 --> [*]: セッション開始
\`\`\`

## KPI
- **認証成功率**: 99.9%以上 - 正当なユーザーの円滑なアクセス確保
- **MFA採用率**: 100% - 全ユーザーの2要素認証実施
- **平均認証時間**: 10秒以内 - ユーザビリティの維持
- **不正アクセス検知率**: 95%以上 - セキュリティ侵害の防止

## ビジネスルール
- パスワードは8文字以上、大小英数記号を含む
- 連続3回失敗でアカウントロック（15分間）
- MFAは全ユーザー必須
- セッション有効期限は8時間、無操作30分で自動ログアウト
- 異なるデバイスからのログインは追加認証が必要

## 入出力仕様
### 入力
- **メールアドレス**: 登録済みユーザーのメールアドレス
- **パスワード**: ハッシュ化前の平文パスワード
- **MFAコード**: 6桁の数値認証コード

### 出力
- **認証トークン**: JWT形式のアクセストークン（有効期限付き）
- **ユーザーセッション**: セッションID、最終アクセス時刻
- **ロール情報**: ユーザーの権限とアクセス可能なリソース

## 例外処理
- **アカウントロック**: ロック解除手順の案内とセキュリティ管理者への通知
- **MFA失敗**: バックアップコード利用の案内
- **システム障害**: 代替認証手段の提供と障害復旧の迅速化`
          },
          {
            name: 'manage-permissions',
            displayName: '権限を管理する',
            pattern: 'CRUD',
            goal: 'ユーザーとリソースに対する適切な権限設定を実現',
            roles: ['セキュリティ管理者', 'システム管理者', 'チームリーダー'],
            businessStates: ['権限設定中', '権限有効', '権限無効', '権限削除'],
            design: `# ビジネスオペレーション: 権限を管理する

## 概要
**目的**: 組織のセキュリティポリシーに基づき、ユーザーとリソースへのアクセス権限を適切に管理する
**パターン**: CRUD
**ゴール**: 最小権限の原則に基づく、セキュアで効率的な権限管理体制の確立

## 関係者とロール
- **セキュリティ管理者**: 権限ポリシーの策定と承認、高権限の管理
- **システム管理者**: 技術的な権限設定とシステムリソースの管理
- **チームリーダー**: チームメンバーの業務権限申請と承認

## プロセスフロー
\`\`\`mermaid
flowchart LR
    A[権限申請] --> B[申請内容確認]
    B --> C[ポリシー適合チェック]
    C --> D{適合?}
    D -->|非適合| E[申請却下]
    D -->|適合| F[承認者割当]
    F --> G[承認プロセス]
    G --> H{承認?}
    H -->|却下| E
    H -->|承認| I[権限付与]
    I --> J[権限有効化]
    J --> K[監査ログ記録]
\`\`\`

### ステップ詳細
1. **権限申請**: 業務上必要な権限をシステムに申請
2. **ポリシー適合チェック**: セキュリティポリシーとの整合性確認
3. **承認プロセス**: 適切な承認者による審査と承認
4. **権限付与**: システムへの権限設定とロール割当
5. **継続監視**: 権限使用状況の監視と定期レビュー

## KPI
- **権限申請処理時間**: 平均24時間以内
- **権限の適正性**: 定期監査での適合率95%以上
- **権限悪用インシデント**: 月1件以下
- **アクセス権限の精度**: 最小権限原則適合率90%以上

## ビジネスルール
- 業務上必要最小限の権限のみを付与
- 権限の定期レビューを四半期ごとに実施
- 職務変更時は即座に権限を見直し
- 重要システムへのアクセスは承認者の承認が必須
- 権限付与・変更・削除はすべて監査ログに記録

## 入出力仕様
### 入力
- **権限申請情報**: ユーザーID、リソース、権限レベル、申請理由
- **承認情報**: 承認者ID、承認結果、承認コメント

### 出力
- **権限設定結果**: 設定された権限の詳細情報
- **監査ログ**: 権限変更の履歴と承認プロセスの記録

## 例外処理
- **緊急時権限**: 緊急時の一時的権限付与手順
- **権限競合**: 複数の権限が競合する場合の解決ルール
- **システム障害**: 権限システム障害時の代替承認手順`
          },
          {
            name: 'audit-access',
            displayName: 'アクセスを監査する',
            pattern: 'Analytics',
            goal: 'システムアクセスの完全な記録と分析により、セキュリティ違反を早期発見',
            roles: ['監査担当者', 'セキュリティアナリスト', 'コンプライアンス担当者'],
            businessStates: ['監査開始', '分析中', 'レポート作成', '監査完了'],
            design: `# ビジネスオペレーション: アクセスを監査する

## 概要
**目的**: システムへのアクセス状況を包括的に監視・記録し、セキュリティインシデントやコンプライアンス違反を早期発見する
**パターン**: Analytics
**ゴール**: 継続的な監査により組織のセキュリティ態勢を維持・向上させる

## 関係者とロール
- **監査担当者**: 定期監査の実施と監査レポートの作成
- **セキュリティアナリスト**: リアルタイム監視と異常検知、インシデント分析
- **コンプライアンス担当者**: 法的要件への適合性確認と報告

## プロセスフロー
\`\`\`mermaid
flowchart LR
    A[アクセスログ収集] --> B[ログ正規化]
    B --> C[異常検知分析]
    C --> D{異常検知?}
    D -->|検知| E[アラート発行]
    D -->|正常| F[定期レポート]
    E --> G[インシデント調査]
    G --> H[対応措置]
    F --> I[監査レポート]
    I --> J[改善提案]
\`\`\`

### ステップ詳細
1. **ログ収集**: 全システムからアクセスログを自動収集
2. **ログ分析**: AI/機械学習による異常パターンの検出
3. **リアルタイム監視**: 24時間365日の継続監視
4. **定期監査**: 月次・四半期の包括的な監査実施
5. **レポート作成**: ステークホルダー向けの監査報告書作成

## KPI
- **ログ収集率**: 99.9%以上の完全性
- **異常検知精度**: 偽陽性率5%以下
- **インシデント対応時間**: 平均30分以内
- **監査レポート提出**: 月次レポートを月末から5営業日以内

## ビジネスルール
- 全アクセスログを最低7年間保管
- 個人情報を含むアクセスは詳細ログを記録
- 特権アカウントのアクセスは即座にアラート
- 営業時間外のアクセスは自動監視を強化
- 監査ログの改ざんは重大なセキュリティ違反として処理

## 入出力仕様
### 入力
- **アクセスログ**: タイムスタンプ、ユーザーID、アクセス先、操作内容
- **セキュリティポリシー**: 監査基準とアラート条件

### 出力
- **監査レポート**: 定期的なアクセス状況の分析結果
- **アラート通知**: 異常検知時の即座の通知
- **ダッシュボード**: リアルタイムのセキュリティ状況表示

## 例外処理
- **ログ収集失敗**: バックアップシステムによる代替収集
- **大量アラート**: アラート疲れを防ぐための優先度付け
- **システム障害**: 監査システム停止時の手動監視手順`
          }
        ]
      }
    ]
  },
  {
    name: 'collaboration-facilitation',
    displayName: 'コラボレーション促進サービス',
    description: 'チーム間の円滑なコミュニケーションと情報共有を実現',
    domainLanguageFile: 'collaboration-facilitation-v2.md',
    capabilities: [
      {
        name: 'communication',
        displayName: '情報を即座に届ける能力',
        description: '通知、メッセージング、情報共有を通じてコラボレーションを促進',
        category: 'Core',
        definition: `# 情報を即座に届ける能力

## 定義
組織内の情報流通を最適化し、適切な人に適切な情報をタイムリーに届ける組織的能力

## 責務
- 重要情報の即座な配信と通知
- チーム間のコミュニケーション促進
- 知識の共有と蓄積の仕組み構築
- 情報の適切な分類と配信経路の管理
- コラボレーションツールの効果的な活用

## 提供価値
- 意思決定速度の向上: 情報伝達時間50%短縮
- チーム間連携の強化: コミュニケーション頻度30%増加
- 重要情報の見落とし防止: 通知到達率99%以上
- 知識の組織内共有促進: ナレッジ活用率60%向上
- リモートワーク環境でのチーム結束力維持

## 実現手段
- 通知を配信する
- 議論を促進する
- 知識を共有する

## 成熟度レベル
- **現在**: レベル2（反復可能）
- **目標**: レベル3（定義され管理されている）
- **改善計画**: AI活用による自動分類と最適配信ルート選択の導入

## 依存関係
- **前提ケーパビリティ**: アクセスを安全に管理する能力
- **関連ケーパビリティ**: 知識を組織資産化する能力、プロジェクトを成功に導く能力`,
        operations: [
          {
            name: 'send-notifications',
            displayName: '通知を配信する',
            pattern: 'Communication',
            goal: '重要な情報を適切なタイミングで関係者に確実に届ける',
            roles: ['システム', 'コミュニケーション管理者', '情報受信者'],
            businessStates: ['通知作成', '配信処理中', '配信完了', '既読確認'],
            design: `# ビジネスオペレーション: 通知を配信する

## 概要
**目的**: 組織内の重要情報を適切な関係者に確実かつタイムリーに届ける
**パターン**: Communication
**ゴール**: 情報の見落としを防ぎ、迅速な意思決定と行動を支援する

## 関係者とロール
- **システム**: 自動通知の生成と配信処理
- **コミュニケーション管理者**: 通知ポリシーの設定と配信管理
- **情報受信者**: 通知の受信と適切な対応

## プロセスフロー
\`\`\`mermaid
flowchart LR
    A[通知発生] --> B[受信者特定]
    B --> C[優先度判定]
    C --> D[配信方法選択]
    D --> E[通知配信]
    E --> F[配信確認]
    F --> G{配信成功?}
    G -->|失敗| H[再配信]
    G -->|成功| I[既読追跡]
    I --> J[レポート生成]
\`\`\`

### ステップ詳細
1. **通知発生**: システムイベントまたは手動による通知生成
2. **受信者特定**: プロジェクト、役割、関心領域に基づく配信リスト作成
3. **優先度判定**: 緊急度に応じた配信方法と頻度の決定
4. **通知配信**: アプリ内、メール、SMS等の複数チャネルでの配信
5. **効果測定**: 既読率、反応率、アクション率の分析

## KPI
- **配信成功率**: 99.5%以上 - 技術的な配信エラーの最小化
- **既読率**: 90%以上 - 受信者による確認率
- **平均既読時間**: 2時間以内 - 迅速な情報確認
- **アクション率**: 70%以上 - 通知に基づく具体的行動の実行

## ビジネスルール
- 緊急通知は複数チャネルで即座に配信
- 営業時間外の通知は翌営業日に集約配信
- 同一内容の重複通知は24時間以内は送信しない
- 個人設定による通知頻度の調整を許可
- 重要通知の未読が48時間継続する場合は上司に escalation

## 入出力仕様
### 入力
- **通知内容**: タイトル、本文、関連リンク、添付ファイル
- **配信対象**: ユーザーID、グループ、役割、プロジェクト
- **優先度**: 緊急、高、中、低

### 出力
- **配信レポート**: 配信状況、既読状況、エラー情報
- **受信確認**: 各受信者の既読タイムスタンプ
- **統計情報**: 配信効果の分析データ

## 例外処理
- **配信失敗**: 代替チャネルでの自動再配信
- **大量配信**: システム負荷制御による段階的配信
- **緊急時**: 配信制限を解除した優先配信`
          },
          {
            name: 'facilitate-discussion',
            displayName: '議論を促進する',
            pattern: 'Communication',
            goal: 'チーム内外での建設的な議論を活性化し、合意形成を支援する',
            roles: ['議論参加者', 'ファシリテーター', 'ステークホルダー'],
            businessStates: ['議論開始', '議論進行中', '合意形成', '議論完了'],
            design: `# ビジネスオペレーション: 議論を促進する

## 概要
**目的**: チーム内外での効果的な議論を促進し、建設的な合意形成を実現する
**パターン**: Communication
**ゴール**: 多様な意見を収集・整理し、質の高い意思決定を支援する

## 関係者とロール
- **議論参加者**: 積極的な意見表明と建設的な討議への貢献
- **ファシリテーター**: 議論の進行管理と中立的な合意形成の支援
- **ステークホルダー**: 意思決定への影響評価と最終承認

## プロセスフロー
\`\`\`mermaid
flowchart LR
    A[議論テーマ設定] --> B[参加者招集]
    B --> C[議論開始]
    C --> D[意見収集]
    D --> E[論点整理]
    E --> F[合意点探索]
    F --> G{合意達成?}
    G -->|未達成| H[追加議論]
    G -->|達成| I[合意事項記録]
    I --> J[アクションプラン]
    H --> D
\`\`\`

### ステップ詳細
1. **議論設計**: 目的、論点、期待成果の明確化
2. **参加者選定**: 適切なステークホルダーの特定と参加依頼
3. **議論実施**: 構造化された議論プロセスの実行
4. **合意形成**: 意見の集約と合意可能な解決策の特定
5. **結果共有**: 議論内容と合意事項の記録・共有

## KPI
- **参加率**: 80%以上 - 関係者の積極的参加
- **合意達成率**: 85%以上 - 建設的な合意形成
- **議論効率**: 予定時間内での完了率90%以上
- **満足度**: 参加者満足度4.0/5.0以上

## ビジネスルール
- 重要な意思決定は必ず関係者全員の議論を経る
- 議論は必ず記録を取り、参加者全員に共有
- 合意できない場合は上位意思決定者にエスカレーション
- 議論中は建設的批判を奨励し、人格攻撃は禁止
- タイムボックスを設定し、効率的な議論を心がける

## 入出力仕様
### 入力
- **議論テーマ**: 議論の目的、背景、論点、期待成果
- **参加者情報**: 参加者リスト、役割、専門分野
- **議論時間**: 開始時刻、終了予定時刻、議論時間枠

### 出力
- **議論記録**: 発言内容、論点、合意事項の詳細記録
- **アクションアイテム**: 具体的な行動計画と担当者、期限
- **次回議論予定**: 未解決事項の継続議論計画

## 例外処理
- **参加率不足**: 代替参加者の確保または延期
- **合意困難**: 第三者ファシリテーターの投入
- **時間超過**: 重要論点に集中した議論の継続`
          },
          {
            name: 'share-knowledge',
            displayName: '知識を共有する',
            pattern: 'Communication',
            goal: '組織内の知識とノウハウを効果的に共有し、集合知を向上させる',
            roles: ['知識提供者', '知識利用者', '知識管理者'],
            businessStates: ['知識作成', '共有準備', '共有実施', '活用促進'],
            design: `# ビジネスオペレーション: 知識を共有する

## 概要
**目的**: 組織内に蓄積された知識・ノウハウを効果的に共有し、組織全体の能力向上を図る
**パターン**: Communication
**ゴール**: 知識の属人化を防ぎ、組織としての学習能力と適応力を強化する

## 関係者とロール
- **知識提供者**: 専門知識や経験の積極的な共有と文書化
- **知識利用者**: 共有された知識の活用と実践での検証
- **知識管理者**: 知識の体系化、品質管理、活用促進

## プロセスフロー
\`\`\`mermaid
flowchart LR
    A[知識発見] --> B[知識構造化]
    B --> C[共有形式選択]
    C --> D[知識共有]
    D --> E[フィードバック収集]
    E --> F[知識改善]
    F --> G[活用促進]
    G --> H[効果測定]
    H --> I[継続改善]
\`\`\`

### ステップ詳細
1. **知識抽出**: 専門家の暗黙知を形式知として明文化
2. **知識整理**: 検索性と理解性を高める構造化
3. **共有実施**: 適切なメディアとタイミングでの知識提供
4. **活用支援**: 知識利用者への適用方法指導
5. **効果測定**: 知識活用による成果と改善効果の評価

## KPI
- **知識共有件数**: 月50件以上の新規知識登録
- **活用率**: 共有知識の70%以上が実際に活用される
- **検索性**: 必要な知識を5分以内で発見できる率90%以上
- **満足度**: 知識利用者の満足度4.2/5.0以上

## ビジネスルール
- 重要な知識は必ず複数人で検証してから共有
- 知識の更新頻度を明記し、古い情報の識別を容易にする
- 機密性の高い知識はアクセス権限を適切に設定
- 知識提供者には適切な認知とインセンティブを提供
- 外部からの知識も内部基準に合わせて評価・整理

## 入出力仕様
### 入力
- **知識コンテンツ**: 文書、動画、音声、図表等の多様な形式
- **メタデータ**: カテゴリ、タグ、作成者、更新日、信頼度
- **利用制限**: アクセス権限、機密レベル、利用条件

### 出力
- **知識ベース**: 検索可能で体系化された知識データベース
- **利用統計**: アクセス数、利用頻度、評価情報
- **推奨知識**: ユーザーの役割や興味に基づく知識推薦

## 例外処理
- **知識競合**: 同一トピックの複数知識における権威性判定
- **品質不足**: 低品質知識の改善要求と品質向上支援
- **アクセス制限**: 機密知識への不適切アクセス試行の検知と対応`
          }
        ]
      }
    ]
  },
  {
    name: 'project-success-support',
    displayName: 'プロジェクト成功支援サービス',
    description: 'プロジェクトを成功に導くための計画策定、実行支援、リスク管理を統合的にサポート',
    domainLanguageFile: 'project-success-v2.md',
    capabilities: [
      {
        name: 'project-success',
        displayName: 'プロジェクトを成功に導く能力',
        description: 'プロジェクトを期限内・予算内で成功に導き、期待を超える成果を提供',
        category: 'Core',
        definition: `# プロジェクトを成功に導く能力

## 定義
プロジェクトの計画から完了まで、全体を統括し成功に導く組織的能力

## 責務
- プロジェクト目標の設定と計画策定
- リスクの早期発見と対策実施
- 進捗の可視化と課題の迅速な解決
- 品質基準の設定と維持
- ステークホルダーとの効果的なコミュニケーション

## 提供価値
- プロジェクト成功率の向上: 目標達成率95%以上
- 計画精度の向上: 初期見積もりとの乖離±10%以内
- リスクの最小化: リスク顕在化率10%以下
- ステークホルダー満足度の向上: 満足度4.5/5.0以上
- 組織のプロジェクト管理成熟度向上

## 実現手段
- プロジェクトを計画する
- リスクを管理する
- 進捗を追跡する
- 品質を保証する
- 成果物を納品する

## 成熟度レベル
- **現在**: レベル2（反復可能）
- **目標**: レベル4（定量的に管理されている）
- **改善計画**: PMOの設立とKPI自動測定システムの導入

## 依存関係
- **前提ケーパビリティ**: チームの生産性を最大化する能力
- **関連ケーパビリティ**: 工数を正確に把握する能力、収益性を最適化する能力`,
        operations: [
          {
            name: 'plan-project',
            displayName: 'プロジェクトを計画する',
            pattern: 'Workflow',
            goal: 'プロジェクトの目標、スコープ、スケジュール、リソース計画を策定し、成功への道筋を明確にする',
            roles: ['プロジェクトマネージャー', 'ビジネスアナリスト', 'クライアント', 'チームリーダー'],
            businessStates: ['計画開始', '要件定義', 'スコープ確定', 'スケジュール作成', '計画承認'],
            design: `# ビジネスオペレーション: プロジェクトを計画する

## 概要
**目的**: プロジェクトの成功確率を最大化するための包括的な計画を策定する
**パターン**: Workflow
**ゴール**: 明確な目標、現実的なスケジュール、適切なリソース配分による実行可能な計画の確立

## 関係者とロール
- **プロジェクトマネージャー**: 計画全体の統括と関係者間の調整
- **ビジネスアナリスト**: 要件の詳細分析と業務プロセスの設計
- **クライアント**: 要件提供と計画内容の承認
- **チームリーダー**: 技術的実現性の評価とリソース見積もり

## プロセスフロー
\`\`\`mermaid
flowchart LR
    A[プロジェクト開始] --> B[要件収集]
    B --> C[スコープ定義]
    C --> D[WBS作成]
    D --> E[スケジュール策定]
    E --> F[リソース計画]
    F --> G[リスク評価]
    G --> H[計画レビュー]
    H --> I{承認?}
    I -->|修正必要| J[計画修正]
    I -->|承認| K[計画確定]
    J --> H
\`\`\`

### ステップ詳細
1. **要件収集**: ステークホルダーからの要求事項の詳細聞き取り
2. **スコープ定義**: プロジェクトの境界と成果物の明確化
3. **WBS作成**: 作業を詳細に分解し、作業パッケージを定義
4. **スケジュール策定**: 依存関係を考慮した現実的なタイムライン作成
5. **リソース計画**: 必要なスキルと工数の詳細な見積もり

## KPI
- **計画精度**: 初期見積もりとの乖離±10%以内
- **ステークホルダー合意**: 全員合意達成率100%
- **計画策定期間**: 標準期間内での完了率90%以上
- **要件変更率**: プロジェクト開始後の要件変更15%以下

## ビジネスルール
- 重要なプロジェクトは必ず複数の専門家でレビュー
- 計画は最低3つのシナリオ（楽観・標準・悲観）で作成
- ステークホルダー全員の承認を得てから実行開始
- 計画変更は影響分析を実施してから承認
- 過去のプロジェクトデータを必ず参考にする

## 入出力仕様
### 入力
- **プロジェクト憲章**: 目的、目標、主要ステークホルダー
- **要件仕様書**: 機能要件、非機能要件、制約条件
- **組織標準**: PMO標準、品質基準、リスク管理方針

### 出力
- **プロジェクト計画書**: WBS、スケジュール、リソース計画
- **リスク登録簿**: 識別されたリスクと対策
- **コミュニケーション計画**: 報告頻度、会議体、責任者

## 例外処理
- **要件不明確**: 追加の要件定義セッションの実施
- **リソース不足**: 代替リソースの確保または計画の見直し
- **承認遅延**: エスカレーション手順の実行`
          }
        ]
      }
    ]
  },
  {
    name: 'talent-optimization',
    displayName: 'タレント最適化サービス',
    description: '人材の能力を最大化し、適材適所の配置と成長機会を提供',
    domainLanguageFile: 'talent-optimization-v2.md',
    capabilities: [
      {
        name: 'talent-management',
        displayName: 'チームの生産性を最大化する能力',
        description: 'スキル管理、配置最適化、パフォーマンス向上を実現',
        category: 'Core',
        definition: `# チームの生産性を最大化する能力

## 定義
人材の能力を最適に配置し、個人とチームのパフォーマンスを最大化する組織的能力

## 責務
- スキルの可視化と育成計画の策定
- プロジェクトニーズに応じた最適な人材配置
- パフォーマンス評価と継続的な改善支援
- キャリア開発とモチベーション向上の仕組み構築
- チーム形成と協働効果の最大化

## 提供価値
- 生産性向上: 個人パフォーマンス20%向上
- スキルマッチング精度向上: 配置適合率90%以上
- 従業員満足度向上: エンゲージメントスコア4.0/5.0以上
- スキル開発の加速: 目標達成率85%以上
- 組織の人材競争力強化

## 実現手段
- スキルを管理する
- リソースを最適配置する
- タレントを育成する

## 成熟度レベル
- **現在**: レベル2（反復可能）
- **目標**: レベル4（定量的に管理されている）
- **改善計画**: AI活用による最適配置アルゴリズムとスキル成長予測の導入

## 依存関係
- **前提ケーパビリティ**: アクセスを安全に管理する能力
- **関連ケーパビリティ**: プロジェクトを成功に導く能力、工数を正確に把握する能力`,
        operations: [
          {
            name: 'manage-skills',
            displayName: 'スキルを管理する',
            pattern: 'CRUD',
            goal: 'メンバーのスキルを可視化し育成',
            roles: ['HRマネージャー', 'チームリーダー', 'メンバー'],
            businessStates: ['スキル評価', 'スキル登録', 'スキル更新', 'スキル承認'],
            design: `# ビジネスオペレーション: スキルを管理する

## 概要
**目的**: 組織内の人材スキルを体系的に管理し、適切な配置と育成を実現する
**パターン**: CRUD
**ゴール**: スキルの可視化により最適な人材活用と継続的な能力向上を支援する

## 関係者とロール
- **HRマネージャー**: スキル体系の策定と全社的なスキル管理
- **チームリーダー**: チーム内スキル評価と育成計画の作成
- **メンバー**: 自己スキル申告と継続的なスキルアップ

## KPI
- **スキル登録率**: 全メンバーの95%以上
- **スキル評価精度**: 第三者評価との一致率85%以上
- **スキル更新頻度**: 四半期ごとの更新率80%以上
- **スキル活用率**: 登録スキルの実務活用率70%以上

## ビジネスルール
- スキル評価は客観的な基準に基づいて実施
- 重要スキルは複数人による評価を必須とする
- スキル情報は本人の同意なく第三者に開示しない
- スキル育成計画は本人の意向を最大限尊重
- スキル評価結果は人事評価に直結させない

## 入出力仕様
### 入力
- **スキル情報**: スキル名、レベル、証明書、実務経験
- **評価情報**: 自己評価、上司評価、第三者評価

### 出力
- **スキルマップ**: 組織全体のスキル分布と強み・弱み
- **育成計画**: 個人別・チーム別のスキル向上計画

## 例外処理
- **スキル評価困難**: 専門家による外部評価の実施
- **スキル不足**: 外部研修や採用による補完`
          }
        ]
      }
    ]
  },
  {
    name: 'productivity-visualization',
    displayName: '生産性可視化サービス',
    description: '工数データを分析し、生産性向上のインサイトを提供',
    domainLanguageFile: 'productivity-visualization-v2.md',
    capabilities: [
      {
        name: 'productivity-analysis',
        displayName: '工数を正確に把握する能力',
        description: '工数記録、分析、最適化提案を通じて生産性を向上',
        category: 'Core',
        definition: `# 工数を正確に把握する能力

## 定義
プロジェクトの工数を正確に記録・分析し、生産性向上のインサイトを提供する組織的能力

## 責務
- 工数の正確な記録と承認プロセスの管理
- 工数データの分析と生産性指標の算出
- プロジェクト別・メンバー別の稼働状況の可視化
- 工数予実管理と改善提案の実施
- 適正な工数配分と負荷平準化の支援

## 提供価値
- 工数記録精度の向上: 記録率95%以上
- 生産性の可視化: 時間当たり成果物の定量化
- プロジェクト予算管理の精度向上: 予実差異±5%以内
- メンバーの負荷バランス最適化
- データドリブンなプロジェクト改善

## 実現手段
- 工数を記録する
- 生産性を分析する
- 作業負荷を最適化する

## 成熟度レベル
- **現在**: レベル2（反復可能）
- **目標**: レベル3（定義され管理されている）
- **改善計画**: AI活用による工数予測と自動アラート機能の導入

## 依存関係
- **前提ケーパビリティ**: プロジェクトを成功に導く能力
- **関連ケーパビリティ**: チームの生産性を最大化する能力`,
        operations: [
          {
            name: 'record-timesheet',
            displayName: '工数を記録する',
            pattern: 'CRUD',
            goal: '正確な作業時間を記録',
            roles: ['メンバー', '承認者', 'PMO'],
            businessStates: ['記録中', '承認待ち', '承認済み', '却下'],
            design: `# ビジネスオペレーション: 工数を記録する

## 概要
**目的**: プロジェクトの実工数を正確に記録し、生産性分析の基盤データを構築する
**パターン**: CRUD
**ゴール**: 信頼性の高い工数データにより、正確な分析と改善を実現する

## 関係者とロール
- **メンバー**: 日々の作業時間の正確な記録
- **承認者**: 工数記録の妥当性確認と承認
- **PMO**: 工数記録の品質管理と分析

## KPI
- **記録率**: 営業日の95%以上で工数記録
- **記録精度**: 実工数との差異±10%以内
- **承認時間**: 平均24時間以内での承認完了
- **記録完了率**: 月末から3営業日以内の記録完了率90%以上

## ビジネスルール
- 15分単位での工数記録を基本とする
- 1日の工数は8時間を基準とし、残業は別途記録
- プロジェクト外の工数も管理工数として記録
- 工数修正は承認者の承認が必要
- 月末締めで工数確定、翌月3営業日以内に承認完了

## 入出力仕様
### 入力
- **作業情報**: 日付、プロジェクト、タスク、作業時間、作業内容
- **承認情報**: 承認者、承認日時、承認コメント

### 出力
- **工数サマリー**: 個人別・プロジェクト別の集計データ
- **承認状況**: 承認待ち・承認済み工数の一覧

## 例外処理
- **記録漏れ**: 自動リマインダーによる記録促進
- **記録遅延**: 上長への自動エスカレーション`
          }
        ]
      }
    ]
  },
  {
    name: 'knowledge-cocreation',
    displayName: 'ナレッジ共創サービス',
    description: '組織の知見を集約し、新たな価値を創造する知識基盤を構築',
    domainLanguageFile: 'knowledge-cocreation-v2.md',
    capabilities: [
      {
        name: 'knowledge-management',
        displayName: '知識を組織資産化する能力',
        description: 'ナレッジの蓄積、共有、活用を通じて組織知を強化',
        category: 'Core',
        definition: `# 知識を組織資産化する能力

## 定義
組織内に蓄積された知識を体系化し、組織全体の学習能力と競争優位性を向上させる組織的能力

## 責務
- 知識の収集と構造化
- 知識の品質管理と更新
- 知識の効果的な検索と発見
- 知識活用の促進と成果測定
- 知識創造プロセスの最適化

## 提供価値
- 知識再利用による効率化: 作業時間30%短縮
- イノベーション創出: 新しいアイデア創出率50%向上
- 組織学習の加速: 学習サイクル時間40%短縮
- 意思決定品質の向上: エビデンス基盤の意思決定率80%以上
- 競争優位性の構築: 独自知識による差別化実現

## 実現手段
- 知識を蓄積する
- 知識を体系化する
- 知識を活用する

## 成熟度レベル
- **現在**: レベル2（反復可能）
- **目標**: レベル4（定量的に管理されている）
- **改善計画**: AI活用による知識推薦システムと自動分類機能の導入

## 依存関係
- **前提ケーパビリティ**: 情報を即座に届ける能力
- **関連ケーパビリティ**: プロジェクトを成功に導く能力`,
        operations: [
          {
            name: 'capture-knowledge',
            displayName: '知識を蓄積する',
            pattern: 'CRUD',
            goal: 'プロジェクトの学びを記録',
            roles: ['ナレッジワーカー', 'ナレッジマネージャー', 'エキスパート'],
            businessStates: ['収集中', '構造化中', 'レビュー中', '蓄積完了'],
            design: `# ビジネスオペレーション: 知識を蓄積する

## 概要
**目的**: 組織内の暗黙知を形式知として体系的に蓄積し、組織資産として活用可能にする
**パターン**: CRUD
**ゴール**: 知識の散逸を防ぎ、継続的な学習と改善を支援する知識基盤を構築する

## 関係者とロール
- **ナレッジワーカー**: 日常業務での知識創出と記録
- **ナレッジマネージャー**: 知識の品質管理と体系化
- **エキスパート**: 専門知識の提供と知識の検証

## KPI
- **知識蓄積件数**: 月50件以上の新規知識登録
- **知識品質**: 5段階評価で平均4.0以上
- **知識更新率**: 四半期ごとの更新率60%以上
- **専門家参加率**: エキスパートの80%が知識提供に参加

## ビジネスルール
- 重要な知識は必ず複数の専門家で検証
- 知識には必ず適用範囲と制約条件を明記
- 機密性の高い知識は適切なアクセス制御を設定
- 知識の陳腐化を防ぐため定期的な見直しを実施
- 知識提供者には適切な認知とインセンティブを提供

## 入出力仕様
### 入力
- **知識内容**: 文書、動画、図表、音声等の多様な形式
- **メタデータ**: カテゴリ、タグ、信頼度、適用範囲
- **関連情報**: 参考文献、関連プロジェクト、専門分野

### 出力
- **構造化知識**: 検索可能で体系化された知識データ
- **知識マップ**: 知識間の関連性と依存関係
- **品質指標**: 知識の信頼性と有用性の評価

## 例外処理
- **知識競合**: 同一領域の知識における優先度判定
- **品質不足**: 改善要求と専門家による再検証
- **機密漏洩**: 不適切なアクセスの検知と対応`
          }
        ]
      }
    ]
  },
  {
    name: 'revenue-optimization',
    displayName: '収益最適化サービス',
    description: 'プロジェクト収益を最大化し、コスト効率を改善',
    domainLanguageFile: 'revenue-optimization-v2.md',
    capabilities: [
      {
        name: 'financial-management',
        displayName: '収益性を最適化する能力',
        description: '収益追跡、コスト管理、利益率改善を実現',
        category: 'Core',
        definition: `# 収益性を最適化する能力

## 定義
プロジェクトの収益性を継続的に監視・分析し、利益率の最大化を実現する組織的能力

## 責務
- 収益とコストの正確な把握と分析
- 利益率向上のための戦略策定と実行
- 財務リスクの早期発見と対策
- 投資対効果の測定と改善
- ステークホルダーへの財務報告

## 提供価値
- 利益率の向上: プロジェクト利益率20%以上
- コスト効率の改善: 運営コスト15%削減
- 収益予測精度の向上: 予実差異±5%以内
- 投資判断の最適化: ROI基準による意思決定
- 財務透明性の確保: ステークホルダーへの適切な報告

## 実現手段
- 収益を追跡する
- コストを管理する
- 収益性を最適化する

## 成熟度レベル
- **現在**: レベル2（反復可能）
- **目標**: レベル3（定義され管理されている）
- **改善計画**: 予測分析とリアルタイム財務ダッシュボードの導入

## 依存関係
- **前提ケーパビリティ**: プロジェクトを成功に導く能力、工数を正確に把握する能力
- **関連ケーパビリティ**: なし（独立性の高い能力）`,
        operations: [
          {
            name: 'track-revenue',
            displayName: '収益を追跡する',
            pattern: 'Analytics',
            goal: 'プロジェクト収益を正確に把握',
            roles: ['財務担当者', 'プロジェクトマネージャー', '経営陣'],
            businessStates: ['収益発生', '記録中', '確定', '報告済み'],
            design: `# ビジネスオペレーション: 収益を追跡する

## 概要
**目的**: プロジェクトの収益を正確に把握し、収益性の向上を支援する
**パターン**: Analytics
**ゴール**: リアルタイムな収益把握により、迅速な経営判断と改善行動を実現する

## 関係者とロール
- **財務担当者**: 収益データの正確な記録と分析
- **プロジェクトマネージャー**: プロジェクトレベルの収益管理
- **経営陣**: 収益情報に基づく戦略的意思決定

## KPI
- **収益把握精度**: 実績との差異±3%以内
- **収益報告の迅速性**: 月次レポートを翌月5営業日以内
- **収益予測精度**: 四半期予測の精度±5%以内
- **収益可視化**: リアルタイムダッシュボードの利用率90%以上

## ビジネスルール
- 収益認識は会計基準に厳格に準拠
- プロジェクト単位での収益管理を基本とする
- 月次での収益確定と報告を実施
- 収益予測は保守的な見積もりを採用
- 重要な収益変動は即座に経営陣に報告

## 入出力仕様
### 入力
- **契約情報**: 契約金額、支払条件、マイルストーン
- **進捗情報**: 作業完了率、成果物納品状況
- **変更情報**: 契約変更、追加作業、スコープ変更

### 出力
- **収益レポート**: 月次・四半期・年次の収益分析
- **収益予測**: 将来の収益見込みと達成確度
- **収益ダッシュボード**: リアルタイムの収益状況表示

## 例外処理
- **収益遅延**: 回収遅延の原因分析と対策
- **収益取消**: 契約キャンセル時の損失最小化
- **システム障害**: 手動による収益追跡の継続`
          }
        ]
      }
    ]
  }
]

async function seedAllServicesCompleteV2() {
  console.log('🚀 Starting complete Parasol seed V2 for all services...')

  try {
    // Clear existing data
    console.log('🧹 Clearing existing data...')
    await parasolDb.testDefinition.deleteMany()
    await parasolDb.pageDefinition.deleteMany()
    await parasolDb.useCase.deleteMany()
    await parasolDb.businessOperation.deleteMany()
    await parasolDb.businessCapability.deleteMany()
    await parasolDb.service.deleteMany()

    let totalServices = 0
    let totalCapabilities = 0
    let totalOperations = 0

    for (const serviceConfig of services) {
      console.log(`\n📦 Creating ${serviceConfig.displayName}...`)

      // Load domain language
      const domainLanguagePath = join(__dirname, '../domain-languages', serviceConfig.domainLanguageFile)
      let domainLanguage = ''
      try {
        domainLanguage = readFileSync(domainLanguagePath, 'utf-8')
      } catch (error) {
        console.warn(`  ⚠️ Domain language file not found: ${serviceConfig.domainLanguageFile}`)
        domainLanguage = '# Domain Language\nNot yet defined.'
      }

      // Create service
      const service = await parasolDb.service.create({
        data: {
          name: serviceConfig.name,
          displayName: serviceConfig.displayName,
          description: serviceConfig.description,
          domainLanguage: JSON.stringify({ content: domainLanguage }),
          apiSpecification: JSON.stringify({ endpoints: [] }),
          dbSchema: JSON.stringify({ tables: [] })
        }
      })
      totalServices++
      console.log(`  ✅ Service created: ${service.displayName}`)

      // Create capabilities and operations
      for (const capConfig of serviceConfig.capabilities) {
        const capability = await parasolDb.businessCapability.create({
          data: {
            serviceId: service.id,
            name: capConfig.name,
            displayName: capConfig.displayName,
            description: capConfig.description,
            category: capConfig.category,
            definition: capConfig.definition
          }
        })
        totalCapabilities++
        console.log(`    ✅ Capability created: ${capability.displayName}`)

        // Create operations
        for (const opConfig of capConfig.operations) {
          await parasolDb.businessOperation.create({
            data: {
              serviceId: service.id,
              capabilityId: capability.id,
              name: opConfig.name,
              displayName: opConfig.displayName,
              pattern: opConfig.pattern,
              goal: opConfig.goal,
              operations: JSON.stringify([]),
              businessStates: JSON.stringify(opConfig.businessStates),
              roles: JSON.stringify(opConfig.roles),
              useCases: JSON.stringify([]),
              uiDefinitions: JSON.stringify([]),
              testCases: JSON.stringify([]),
              robustnessModel: JSON.stringify({}),
              design: opConfig.design
            }
          })
          totalOperations++
        }
        console.log(`      Created ${capConfig.operations.length} operations with detailed designs`)
      }
    }

    console.log('\n📊 Summary:')
    console.log(`  ✅ Services: ${totalServices}`)
    console.log(`  ✅ Capabilities: ${totalCapabilities}`)
    console.log(`  ✅ Operations: ${totalOperations}`)
    console.log('\n✨ Complete Parasol seed V2 finished successfully!')

    return { services: totalServices, capabilities: totalCapabilities, operations: totalOperations }

  } catch (error) {
    console.error('❌ Error in seedAllServicesCompleteV2:', error)
    throw error
  } finally {
    await parasolDb.$disconnect()
  }
}

// Direct execution
if (require.main === module) {
  seedAllServicesCompleteV2()
    .then(result => {
      console.log('✅ Seed completed successfully')
      process.exit(0)
    })
    .catch(error => {
      console.error('❌ Seed failed:', error)
      process.exit(1)
    })
}

export { seedAllServicesCompleteV2 }